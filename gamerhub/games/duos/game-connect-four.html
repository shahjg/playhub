<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Connect Four â€“ 2 Player Game | TheGaming.co</title>
    <meta name="description" content="Classic Connect Four for 2 players or vs AI. Drop discs and connect four to win!">
    <meta name="theme-color" content="#0a0a0f">
    <link rel="stylesheet" href="/header.css">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        :root{
            --accent:#f472b6;--accent-dark:#db2777;--accent-light:#fce7f3;
            --p1:#ef4444;--p2:#facc15;
            --pink:#ff6b9d;--blue:#4facfe;--purple:#a855f7;
            --gold:#ffd700;--text-dark:#1a1a2e;--text-muted:#6b7280;
        }
        html{-webkit-tap-highlight-color:transparent;touch-action:manipulation}
        body{font-family:'Inter',sans-serif;background:linear-gradient(135deg,#fce7f3 0%,#fbcfe8 50%,#fdf2f8 100%);color:var(--text-dark);min-height:100vh;min-height:100dvh;display:flex;flex-direction:column;overflow-x:hidden;padding-bottom:env(safe-area-inset-bottom)}
        h1,h2,h3,h4{font-family:'Bebas Neue',sans-serif;letter-spacing:1px}
        a{color:inherit;text-decoration:none}

        main{flex:1;display:flex;flex-direction:column;padding-top:60px}

        .game-hero{background:radial-gradient(circle at 10% 0%,#9d174d 0%,#831843 50%,#500724 100%);padding:40px 20px;text-align:center;position:relative;overflow:hidden}
        .game-hero::before{content:'';position:absolute;inset:0;background:radial-gradient(circle at 30% 20%,rgba(244,114,182,0.3) 0%,transparent 55%)}
        .hero-content{position:relative;z-index:1;max-width:600px;margin:0 auto}
        .hero-icon{width:60px;height:60px;margin:0 auto 16px;animation:iconFloat 3s ease-in-out infinite}
        @keyframes iconFloat{0%,100%{transform:translateY(0) rotate(-2deg)}50%{transform:translateY(-8px) rotate(2deg)}}
        .hero-title{font-size:clamp(2.5rem,8vw,4rem);line-height:0.95;margin-bottom:8px;background:linear-gradient(135deg,#fff,var(--accent-light),var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;letter-spacing:3px}
        .hero-sub{font-size:0.9rem;color:rgba(255,255,255,0.7)}

        .game-wrapper{flex:1;display:flex;flex-direction:column;align-items:center;padding:30px 16px 50px}
        .game-container{width:100%;max-width:420px;display:flex;flex-direction:column;gap:16px}

        .mode-selection{background:#fff;border-radius:20px;padding:32px 24px;box-shadow:0 8px 30px rgba(244,114,182,0.1);text-align:center}
        .mode-title{font-family:'Bebas Neue',sans-serif;font-size:1.8rem;letter-spacing:2px;margin-bottom:8px;color:var(--text-dark)}
        .mode-subtitle{font-size:0.9rem;color:var(--text-muted);margin-bottom:24px}
        .mode-buttons{display:flex;flex-direction:column;gap:12px}
        .mode-btn{padding:16px 24px;border-radius:14px;border:2px solid rgba(244,114,182,0.15);background:#fff;font-family:'Inter',sans-serif;font-weight:600;font-size:0.95rem;cursor:pointer;transition:all 0.3s;display:flex;align-items:center;justify-content:space-between}
        .mode-btn:hover{border-color:var(--accent);background:#fdf2f8;transform:translateY(-2px)}
        .mode-btn-icon{font-size:1.5rem}
        .mode-btn-text{text-align:left;flex:1;margin:0 12px}
        .mode-btn-label{display:block;font-size:1.1rem;color:var(--text-dark);margin-bottom:2px}
        .mode-btn-desc{display:block;font-size:0.75rem;color:var(--text-muted);font-weight:500}

        .score-bar{display:grid;grid-template-columns:1fr 1fr;gap:12px}
        .score-card{background:#fff;border:2px solid rgba(244,114,182,0.15);border-radius:14px;padding:12px;text-align:center;box-shadow:0 2px 12px rgba(244,114,182,0.08);transition:all 0.3s;display:flex;align-items:center;justify-content:center;gap:10px}
        .score-card.active{border-color:var(--accent);box-shadow:0 4px 20px rgba(244,114,182,0.2)}
        .score-disc{width:24px;height:24px;border-radius:50%;flex-shrink:0}
        .score-disc.red{background:linear-gradient(135deg,#ef4444,#dc2626)}
        .score-disc.yellow{background:linear-gradient(135deg,#facc15,#eab308)}
        .score-info{text-align:left}
        .score-label{font-size:0.65rem;font-weight:600;text-transform:uppercase;letter-spacing:1px;color:var(--text-muted)}
        .score-value{font-family:'Bebas Neue',sans-serif;font-size:1.4rem;letter-spacing:1px;color:var(--text-dark)}

        .turn-indicator{text-align:center;padding:8px;font-size:0.85rem;font-weight:600;color:var(--text-muted)}
        .turn-indicator span{font-family:'Bebas Neue',sans-serif;font-size:1.1rem;letter-spacing:2px}
        .turn-indicator.p1 span{color:var(--p1)}
        .turn-indicator.p2 span{color:#ca8a04}

        .game-board{background:#fff;border-radius:20px;border:2px solid rgba(244,114,182,0.15);padding:16px;box-shadow:0 8px 30px rgba(244,114,182,0.1)}
        .board-wrapper{background:linear-gradient(135deg,#3b82f6,#1d4ed8);border-radius:12px;padding:10px;display:inline-block;margin:0 auto}
        .board-grid{display:grid;grid-template-columns:repeat(7,1fr);gap:6px}
        .cell{width:40px;height:40px;background:#e0f2fe;border-radius:50%;cursor:pointer;transition:all 0.2s;position:relative}
        .cell:hover:not(.taken){background:#bae6fd}
        .cell.red{background:linear-gradient(135deg,#ef4444,#dc2626);cursor:default}
        .cell.yellow{background:linear-gradient(135deg,#facc15,#eab308);cursor:default}
        .cell.winner::after{content:'';position:absolute;inset:-3px;border:3px solid #fff;border-radius:50%;animation:winRing 0.5s ease}
        @keyframes winRing{0%{transform:scale(0.8);opacity:0}100%{transform:scale(1);opacity:1}}

        .game-status{text-align:center;padding:16px;min-height:60px}
        .status-text{font-family:'Bebas Neue',sans-serif;font-size:1.4rem;letter-spacing:2px;color:var(--text-dark)}
        .status-text.win{color:var(--accent-dark)}

        .actions{display:flex;gap:10px;justify-content:center}
        .btn{padding:12px 24px;border-radius:50px;border:none;font-family:'Inter',sans-serif;font-weight:600;font-size:0.85rem;cursor:pointer;transition:all 0.2s;text-transform:uppercase;letter-spacing:1px}
        .btn-primary{background:linear-gradient(135deg,var(--accent),var(--accent-dark));color:#fff;box-shadow:0 4px 15px rgba(244,114,182,0.3)}
        .btn-primary:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(244,114,182,0.4)}
        .btn-secondary{background:#fff;color:var(--text-dark);border:2px solid rgba(244,114,182,0.2)}
        .btn-secondary:hover{border-color:var(--accent)}

        .hidden{display:none!important}

        @media(max-width:400px){
            .cell{width:34px;height:34px}
            .board-grid{gap:4px}
            .board-wrapper{padding:8px}
        }
    </style>
</head>
<body>
    <div id="site-header"></div>
    <main>
        <section class="game-hero">
            <div class="hero-content">
                <div class="hero-icon">
                    <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect x="8" y="16" width="48" height="40" rx="6" fill="#3b82f6"/>
                        <circle cx="20" cy="28" r="6" fill="#e0f2fe"/>
                        <circle cx="32" cy="28" r="6" fill="#ef4444"/>
                        <circle cx="44" cy="28" r="6" fill="#e0f2fe"/>
                        <circle cx="20" cy="44" r="6" fill="#facc15"/>
                        <circle cx="32" cy="44" r="6" fill="#ef4444"/>
                        <circle cx="44" cy="44" r="6" fill="#facc15"/>
                    </svg>
                </div>
                <h1 class="hero-title">CONNECT FOUR</h1>
                <p class="hero-sub">Drop discs and connect four in a row to win!</p>
            </div>
        </section>

        <div class="game-wrapper">
            <div class="game-container">
                <div class="mode-selection" id="modeSelection">
                    <div class="mode-title">Choose Game Mode</div>
                    <div class="mode-subtitle">Play with a friend or challenge the AI</div>
                    <div class="mode-buttons">
                        <button class="mode-btn" onclick="startGame('player')">
                            <span class="mode-btn-icon">ðŸ‘¥</span>
                            <div class="mode-btn-text">
                                <span class="mode-btn-label">vs Player</span>
                                <span class="mode-btn-desc">Play with a friend locally</span>
                            </div>
                            <span style="font-size:1.2rem">â†’</span>
                        </button>
                        <button class="mode-btn" onclick="startGame('ai')">
                            <span class="mode-btn-icon">ðŸ¤–</span>
                            <div class="mode-btn-text">
                                <span class="mode-btn-label">vs AI</span>
                                <span class="mode-btn-desc">Challenge the computer</span>
                            </div>
                            <span style="font-size:1.2rem">â†’</span>
                        </button>
                    </div>
                </div>

                <div id="gameArea" class="hidden">
                    <div class="score-bar">
                        <div class="score-card" id="cardRed">
                            <div class="score-disc red"></div>
                            <div class="score-info">
                                <div class="score-label" id="labelRed">Red</div>
                                <div class="score-value" id="scoreRed">0</div>
                            </div>
                        </div>
                        <div class="score-card" id="cardYellow">
                            <div class="score-disc yellow"></div>
                            <div class="score-info">
                                <div class="score-label" id="labelYellow">Yellow</div>
                                <div class="score-value" id="scoreYellow">0</div>
                            </div>
                        </div>
                    </div>

                    <div class="turn-indicator p1" id="turnIndicator"><span>RED</span>'s turn</div>

                    <div class="game-board">
                        <div class="board-wrapper">
                            <div class="board-grid" id="board"></div>
                        </div>
                    </div>

                    <div class="game-status">
                        <div class="status-text" id="statusText"></div>
                    </div>

                    <div class="actions">
                        <button class="btn btn-primary" onclick="resetGame()">New Game</button>
                        <button class="btn btn-secondary" onclick="changeMode()">Change Mode</button>
                    </div>
                </div>
            </div>
        </div>
    </main>

<script>
const SUPABASE_URL='https://tvvivtmzofsyehatzlvl.supabase.co';
const SUPABASE_ANON_KEY='eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR2dml2dG16b2ZzeWVoYXR6bHZsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4OTExODYsImV4cCI6MjA4MDQ2NzE4Nn0.Qy8kHMO0Nb4yJ0ZHjby7RuQtzwWB8rUcZvkdnbL1b3M';
const supabaseClient=supabase.createClient(SUPABASE_URL,SUPABASE_ANON_KEY);
window.supabaseClient=supabaseClient;

const ROWS=6,COLS=7;
let board=[];
let current='red';
let gameActive=true;
let scores={red:0,yellow:0};
let gameMode='player';
let isAiThinking=false;
let lastPlayerMove=-1;

// TOXIC TRASH TALK
const trashTalk={
    start:[
        "Ready to witness perfection? ðŸ˜",
        "I've already calculated your defeat ðŸ¤–",
        "Minimax says you're cooked ðŸ’€",
        "This won't even be close...",
        "Pro tip: Try vs Player mode instead ðŸ¤¡"
    ],
    block:[
        "LMAOOO did you think that would work? ðŸ˜‚",
        "I saw that 6 moves ago, amateur",
        "Blocked. Alpha-beta pruning says sit down ðŸ›‘",
        "Too predictable, I'm running circles around you ðŸ¥±",
        "That's cute. Real cute. ðŸ˜‚",
        "Imagine being this bad against an AI ðŸ’€",
        "My grandmother plays better and she's dead"
    ],
    threat:[
        "Watch this double threat incoming ðŸ˜ˆ",
        "You're about to see some REAL strategy",
        "Already 3 moves ahead of you ðŸ”¥",
        "This is what optimal play looks like",
        "Setting up the funeral âš°ï¸",
        "You can't stop what's coming ðŸ’€",
        "Fork incoming. Google it. ðŸ´"
    ],
    win:[
        "LMAOOO GET ABSOLUTELY DESTROYED ðŸ†",
        "Uninstall the browser bro ðŸ’€",
        "That was embarrassing to watch ðŸ¤¡",
        "I wasn't even trying ðŸ˜´",
        "Skill issue + ratio + you fell off ðŸ“‰",
        "Maybe stick to tic-tac-toe? ðŸ‘¶",
        "Your ancestors are ashamed",
        "That's a 41-move guaranteed win. Look it up. ðŸ¤“"
    ],
    mistake:[
        "BRUH WHAT THE HELL WAS THAT?? ðŸ¤¦",
        "Are you trolling or just that bad?",
        "Thanks for the free win fr ðŸŽ",
        "Did a toddler take over? ðŸ˜‚",
        "My neural network just blue screened from that move",
        "That's not even legal in 37 countries"
    ],
    mid:[
        "Cute move. Still losing tho... ðŸ˜",
        "Bold strategy. Terrible execution. ðŸ¥±",
        "Keep trying, it's adorable ðŸ¥º",
        "Oh you thought you were cooking? ðŸ”¥âŒ"
    ]
}

let lastTrash='';
function showTrashTalk(cat){
    if(gameMode!=='ai')return;
    const msgs=trashTalk[cat];
    let msg=msgs[Math.floor(Math.random()*msgs.length)];
    while(msg===lastTrash&&msgs.length>1){msg=msgs[Math.floor(Math.random()*msgs.length)];}
    lastTrash=msg;
    const ind=document.getElementById('turnIndicator');
    ind.innerHTML=`<span style="color:#a855f7;font-weight:700;">ðŸ¤– ${msg}</span>`;
    ind.style.opacity='1';
    setTimeout(()=>{if(gameActive)updateTurn();},2500);
}

function createBoard(){
    return Array(ROWS).fill(null).map(()=>Array(COLS).fill(null));
}

function startGame(mode){
    gameMode=mode;
    current='red';
    gameActive=true;
    isAiThinking=false;
    lastPlayerMove=-1;
    document.getElementById('modeSelection').classList.add('hidden');
    document.getElementById('gameArea').classList.remove('hidden');
    if(mode==='ai'){
        document.getElementById('labelRed').textContent='You';
        document.getElementById('labelYellow').textContent='AI';
    }else{
        document.getElementById('labelRed').textContent='Red';
        document.getElementById('labelYellow').textContent='Yellow';
    }
    init();
    if(mode==='ai')setTimeout(()=>showTrashTalk('start'),600);
}

function changeMode(){
    document.getElementById('modeSelection').classList.remove('hidden');
    document.getElementById('gameArea').classList.add('hidden');
    scores={red:0,yellow:0};
    updateScores();
}

function init(){
    board=createBoard();
    const boardEl=document.getElementById('board');
    boardEl.innerHTML='';
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            const cell=document.createElement('div');
            cell.className='cell';
            cell.dataset.r=r;
            cell.dataset.c=c;
            cell.addEventListener('click',()=>play(c));
            boardEl.appendChild(cell);
        }
    }
    updateTurn();
    document.getElementById('statusText').textContent='';
}

function play(col){
    if(!gameActive||isAiThinking)return;
    if(gameMode==='ai'&&current==='yellow')return;
    makeMove(col,current);
    if(gameActive&&gameMode==='ai'&&current==='yellow'){
        isAiThinking=true;
        setTimeout(()=>{aiMove();isAiThinking=false;},500);
    }
}

function makeMove(col,player){
    let row=-1;
    for(let r=ROWS-1;r>=0;r--){
        if(!board[r][col]){row=r;break;}
    }
    if(row===-1)return false;
    board[row][col]=player;
    if(player==='red')lastPlayerMove=col;
    const cell=document.querySelector(`[data-r="${row}"][data-c="${col}"]`);
    cell.classList.add(player,'taken');
    const winCells=checkWin(row,col);
    if(winCells){
        gameActive=false;
        winCells.forEach(([r,c])=>document.querySelector(`[data-r="${r}"][data-c="${c}"]`).classList.add('winner'));
        scores[player]++;
        updateScores();
        if(gameMode==='ai'){
            showStatus(player==='red'?'You win!':'AI wins!','win');
        }else{
            showStatus(`${player.toUpperCase()} wins!`,'win');
        }
        document.getElementById('turnIndicator').style.opacity='0';
    }else if(board[0].every(c=>c)){
        gameActive=false;
        showStatus("It's a draw!",'');
        document.getElementById('turnIndicator').style.opacity='0';
    }else{
        current=current==='red'?'yellow':'red';
        updateTurn();
    }
    return true;
}

function aiMove(){
    const col=getBestMove();
    if(col!==-1)makeMove(col,'yellow');
}

function getBestMove(){
    const depth=6;
    
    // OPENING BOOK - Always play center first
    if(board.every(row=>row.every(c=>!c))){
        showTrashTalk('start');
        return 3;
    }
    
    let moves=0;
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            if(board[r][c])moves++;
        }
    }
    
    // Early game - center focus
    if(moves<=3){
        const centerCols=[3,2,4];
        for(const c of centerCols){
            if(getRow(c)!==-1&&!givesFreeWin(c))return c;
        }
    }
    
    // IMMEDIATE WIN
    for(let c=0;c<COLS;c++){
        const r=getRow(c);
        if(r!==-1){
            board[r][c]='yellow';
            if(wins(r,c,'yellow')){
                board[r][c]=null;
                showTrashTalk('win');
                return c;
            }
            board[r][c]=null;
        }
    }
    
    // IMMEDIATE BLOCK
    for(let c=0;c<COLS;c++){
        const r=getRow(c);
        if(r!==-1){
            board[r][c]='red';
            if(wins(r,c,'red')){
                board[r][c]=null;
                // But ONLY block if it doesn't give them a free win above!
                if(!givesFreeWin(c)){
                    showTrashTalk('block');
                    return c;
                }
            }
            board[r][c]=null;
        }
    }
    
    // DOUBLE THREAT
    for(let c=0;c<COLS;c++){
        const r=getRow(c);
        if(r!==-1&&!givesFreeWin(c)){
            board[r][c]='yellow';
            if(hasDoubleThreat(r,c,'yellow')){
                board[r][c]=null;
                showTrashTalk('threat');
                return c;
            }
            board[r][c]=null;
        }
    }
    
    // BLOCK DOUBLE THREAT
    for(let c=0;c<COLS;c++){
        const r=getRow(c);
        if(r!==-1&&!givesFreeWin(c)){
            board[r][c]='red';
            if(hasDoubleThreat(r,c,'red')){
                board[r][c]=null;
                showTrashTalk('block');
                return c;
            }
            board[r][c]=null;
        }
    }
    
    // MINIMAX - but NEVER consider moves that give free wins
    let bestCol=-1;
    let bestScore=-Infinity;
    const colOrder=[3,2,4,1,5,0,6];
    
    for(const c of colOrder){
        const r=getRow(c);
        if(r!==-1&&!givesFreeWin(c)){
            board[r][c]='yellow';
            const score=minimax(depth-1,false,-Infinity,Infinity,moves+1);
            board[r][c]=null;
            
            if(score>bestScore){
                bestScore=score;
                bestCol=c;
            }
        }
    }
    
    if(bestCol!==-1){
        if(bestScore>100)showTrashTalk('threat');
        else if(Math.random()<0.3)showTrashTalk('mid');
        return bestCol;
    }
    
    // If ALL moves give free wins (we're doomed), just play center
    return 3;
}

function givesFreeWin(col){
    // Check if playing this column gives opponent a win on their next turn
    const r=getRow(col);
    if(r===-1)return true; // Column full
    
    // Place our piece
    board[r][col]='yellow';
    
    // Check if opponent can win immediately after
    let opponentWins=false;
    
    // Check the spot above (if exists)
    if(r>0){
        board[r-1][col]='red';
        if(wins(r-1,col,'red')){
            opponentWins=true;
        }
        board[r-1][col]=null;
    }
    
    // Check all other columns for opponent wins
    if(!opponentWins){
        for(let c=0;c<COLS;c++){
            const opponentR=getRow(c);
            if(opponentR!==-1){
                board[opponentR][c]='red';
                if(wins(opponentR,c,'red')){
                    opponentWins=true;
                    board[opponentR][c]=null;
                    break;
                }
                board[opponentR][c]=null;
            }
        }
    }
    
    board[r][col]=null;
    return opponentWins;
}


function minimax(depth,isMaximizing,alpha,beta,moveCount){
    // Check terminal states
    const yellowWin=checkBoardWin('yellow');
    const redWin=checkBoardWin('red');
    
    if(yellowWin)return 10000-moveCount; // Prefer faster wins
    if(redWin)return -10000+moveCount; // Prefer slower losses
    if(isFull())return 0;
    if(depth===0)return evaluateBoard(moveCount);
    
    if(isMaximizing){
        let maxEval=-Infinity;
        for(let c=0;c<COLS;c++){
            const r=getRow(c);
            if(r!==-1){
                board[r][c]='yellow';
                const eval=minimax(depth-1,false,alpha,beta,moveCount+1);
                board[r][c]=null;
                maxEval=Math.max(maxEval,eval);
                alpha=Math.max(alpha,eval);
                if(beta<=alpha)break; // Prune
            }
        }
        return maxEval;
    }else{
        let minEval=Infinity;
        for(let c=0;c<COLS;c++){
            const r=getRow(c);
            if(r!==-1){
                board[r][c]='red';
                const eval=minimax(depth-1,true,alpha,beta,moveCount+1);
                board[r][c]=null;
                minEval=Math.min(minEval,eval);
                beta=Math.min(beta,eval);
                if(beta<=alpha)break; // Prune
            }
        }
        return minEval;
    }
}

function evaluateBoard(moveCount){
    let score=0;
    
    // CENTER CONTROL (critical!)
    for(let r=0;r<ROWS;r++){
        if(board[r][3]==='yellow')score+=10;
        if(board[r][3]==='red')score-=10;
    }
    
    // PARITY STRATEGY - Odd rows favor Player 1 (red), Even rows favor Player 2 (yellow/AI)
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            if(board[r][c]==='yellow'){
                // AI gets bonus on even rows (0,2,4)
                if(r%2===0)score+=3;
                else score+=1;
            }
            if(board[r][c]==='red'){
                // Player gets penalty on even rows
                if(r%2===0)score-=3;
                else score-=1;
            }
        }
    }
    
    // Evaluate all possible lines
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            if(board[r][c]==='yellow'){
                score+=evaluatePosition(r,c,'yellow');
            }
            if(board[r][c]==='red'){
                score-=evaluatePosition(r,c,'red');
            }
        }
    }
    
    return score;
}

function evaluatePosition(row,col,player){
    let score=0;
    const dirs=[[0,1],[1,0],[1,1],[1,-1]];
    
    for(const[dr,dc]of dirs){
        let pieces=1;
        let empty=0;
        let blocked=false;
        
        // Forward
        for(let i=1;i<4;i++){
            const r=row+dr*i,c=col+dc*i;
            if(r<0||r>=ROWS||c<0||c>=COLS){blocked=true;break;}
            if(board[r][c]===player)pieces++;
            else if(!board[r][c])empty++;
            else{blocked=true;break;}
        }
        
        // Backward
        let backBlocked=false;
        for(let i=1;i<4;i++){
            const r=row-dr*i,c=col-dc*i;
            if(r<0||r>=ROWS||c<0||c>=COLS){backBlocked=true;break;}
            if(board[r][c]===player)pieces++;
            else if(!board[r][c])empty++;
            else{backBlocked=true;break;}
        }
        
        // Scoring
        if(pieces===3&&empty>=1&&!blocked&&!backBlocked)score+=100;
        else if(pieces===3&&empty>=1)score+=50;
        else if(pieces===2&&empty>=2)score+=10;
        else if(pieces===2&&empty>=1)score+=3;
    }
    
    return score;
}

function hasDoubleThreat(row,col,player){
    // Check if this move creates 2+ winning threats
    let threats=0;
    const dirs=[[0,1],[1,0],[1,1],[1,-1]];
    
    for(const[dr,dc]of dirs){
        let pieces=1;
        let gaps=[];
        
        for(let i=1;i<4;i++){
            const r=row+dr*i,c=col+dc*i;
            if(r<0||r>=ROWS||c<0||c>=COLS)break;
            if(board[r][c]===player)pieces++;
            else if(!board[r][c])gaps.push([r,c]);
            else break;
        }
        
        for(let i=1;i<4;i++){
            const r=row-dr*i,c=col-dc*i;
            if(r<0||r>=ROWS||c<0||c>=COLS)break;
            if(board[r][c]===player)pieces++;
            else if(!board[r][c])gaps.push([r,c]);
            else break;
        }
        
        // 3-in-a-row with gap = threat
        if(pieces===3&&gaps.length>0)threats++;
    }
    
    return threats>=2;
}

function checkBoardWin(player){
    for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
            if(board[r][c]===player){
                if(wins(r,c,player))return true;
            }
        }
    }
    return false;
}

function isFull(){
    return board[0].every(c=>c!==null);
}


function getRow(c){
    for(let r=ROWS-1;r>=0;r--){
        if(!board[r][c])return r;
    }
    return -1;
}

function wins(row,col,p){
    const dirs=[[0,1],[1,0],[1,1],[1,-1]];
    for(const[dr,dc]of dirs){
        let cnt=1;
        for(let i=1;i<4;i++){
            const r=row+dr*i,c=col+dc*i;
            if(r>=0&&r<ROWS&&c>=0&&c<COLS&&board[r][c]===p)cnt++;
            else break;
        }
        for(let i=1;i<4;i++){
            const r=row-dr*i,c=col-dc*i;
            if(r>=0&&r<ROWS&&c>=0&&c<COLS&&board[r][c]===p)cnt++;
            else break;
        }
        if(cnt>=4)return true;
    }
    return false;
}

function count(row,col,p){
    let max=0;
    const dirs=[[0,1],[1,0],[1,1],[1,-1]];
    for(const[dr,dc]of dirs){
        let cnt=1;
        for(let i=1;i<4;i++){
            const r=row+dr*i,c=col+dc*i;
            if(r>=0&&r<ROWS&&c>=0&&c<COLS&&board[r][c]===p)cnt++;
            else break;
        }
        for(let i=1;i<4;i++){
            const r=row-dr*i,c=col-dc*i;
            if(r>=0&&r<ROWS&&c>=0&&c<COLS&&board[r][c]===p)cnt++;
            else break;
        }
        max=Math.max(max,cnt);
    }
    return max;
}

function checkWin(row,col){
    const dirs=[[0,1],[1,0],[1,1],[1,-1]];
    for(const[dr,dc]of dirs){
        let cells=[[row,col]];
        for(let i=1;i<4;i++){
            const r=row+dr*i,c=col+dc*i;
            if(r>=0&&r<ROWS&&c>=0&&c<COLS&&board[r][c]===current)cells.push([r,c]);
            else break;
        }
        for(let i=1;i<4;i++){
            const r=row-dr*i,c=col-dc*i;
            if(r>=0&&r<ROWS&&c>=0&&c<COLS&&board[r][c]===current)cells.push([r,c]);
            else break;
        }
        if(cells.length>=4)return cells;
    }
    return null;
}

function updateTurn(){
    const el=document.getElementById('turnIndicator');
    if(gameMode==='ai'){
        el.innerHTML=current==='red'?`<span>Your</span> turn`:`<span>AI</span> thinking...`;
    }else{
        el.innerHTML=`<span>${current.toUpperCase()}</span>'s turn`;
    }
    el.className=`turn-indicator p${current==='red'?'1':'2'}`;
    el.style.opacity='1';
    document.getElementById('cardRed').classList.toggle('active',current==='red');
    document.getElementById('cardYellow').classList.toggle('active',current==='yellow');
}

function showStatus(msg,type){
    const el=document.getElementById('statusText');
    el.textContent=msg;
    el.className='status-text'+(type?' '+type:'');
}

function updateScores(){
    document.getElementById('scoreRed').textContent=scores.red;
    document.getElementById('scoreYellow').textContent=scores.yellow;
}

function resetGame(){
    lastPlayerMove=-1;
    current='red';
    gameActive=true;
    isAiThinking=false;
    document.getElementById('cardRed').classList.remove('active');
    document.getElementById('cardYellow').classList.remove('active');
    init();
}

</script>

<script src="/header.js"></script>
<script src="/js/engagement.js" defer></script>
</body>
</html>
